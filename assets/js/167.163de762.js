(window.webpackJsonp=window.webpackJsonp||[]).push([[167],{730:function(t,e,o){"use strict";o.r(e);var a=o(56),s=Object(a.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("h1",{attrs:{id:"react-hooks-source-code"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#react-hooks-source-code"}},[t._v("#")]),t._v(" React Hooks Source Code")]),t._v(" "),o("blockquote",[o("p",[t._v("Hook是React 16.8的新特性。它可以让你在不编写class的情况下使用state以及其他的React特性。以下是笔者在最近三个月使用React Hooks的源码阅读笔记。")]),t._v(" "),o("p",[t._v("（本文部分内容也参考了各个大牛观点，可详见参考链接）")]),t._v(" "),o("p",[t._v("update: 2019-12-06")])]),t._v(" "),o("p"),o("div",{staticClass:"table-of-contents"},[o("ul",[o("li",[o("a",{attrs:{href:"#react-hooks-source-code"}},[t._v("React Hooks Source Code")]),o("ul",[o("li",[o("a",{attrs:{href:"#usestate"}},[t._v("useState")])])])])])]),o("p"),t._v(" "),o("h2",{attrs:{id:"usestate"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#usestate"}},[t._v("#")]),t._v(" useState")]),t._v(" "),o("p",[t._v("在初始化阶段，useState是基于其在组件中的创建顺序加入hook链表的，并且在update阶段是依据之前创建好的链表去获取到相应要更新的hook queue，所以如果每次进入组件的时候useState的声明顺序都不一致，则会在更新阶段无法找到正确的hook queue和update，导致整个setState的逻辑混乱。这也就是为什么不要在循环、条件判断或者子函数中去调用hook，因为这些操作无法保证每次的结果都是一致的。")]),t._v(" "),o("p",[o("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/64881911",target:"_blank",rel:"noopener noreferrer"}},[t._v("State Hook与Effect Hook解析"),o("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=s.exports}}]);